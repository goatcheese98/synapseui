const R = new RegExp("([\\p{Ll}\\d])(\\p{Lu})", "gu"), A = new RegExp("(\\p{Lu})([\\p{Lu}][\\p{Ll}])", "gu"), g = new RegExp("(\\d)\\p{Ll}|(\\p{L})\\d", "u"), i = /[^\p{L}\d]+/giu, s = "$1\0$2", _ = "";
function E(r) {
  let e = r.trim();
  e = e.replace(R, s).replace(A, s), e = e.replace(i, "\0");
  let c = 0, a = e.length;
  for (; e.charAt(c) === "\0"; )
    c++;
  if (c === a)
    return [];
  for (; e.charAt(a - 1) === "\0"; )
    a--;
  return e.slice(c, a).split(/\0/g);
}
function S(r) {
  const e = E(r);
  for (let c = 0; c < e.length; c++) {
    const a = e[c], l = g.exec(a);
    if (l) {
      const u = l.index + (l[1] ?? l[2]).length;
      e.splice(c, 1, a.slice(0, u), a.slice(u));
    }
  }
  return e;
}
function h(r, e) {
  const [c, a, l] = n(r, e);
  return c + a.map(d(e == null ? void 0 : e.locale)).join((e == null ? void 0 : e.delimiter) ?? " ") + l;
}
function T(r, e) {
  const [c, a, l] = n(r, e), u = d(e == null ? void 0 : e.locale), f = C(e == null ? void 0 : e.locale), t = e != null && e.mergeAmbiguousCharacters ? L(u, f) : w(u, f);
  return c + a.map((m, x) => x === 0 ? u(m) : t(m, x)).join((e == null ? void 0 : e.delimiter) ?? "") + l;
}
function F(r, e) {
  const [c, a, l] = n(r, e), u = d(e == null ? void 0 : e.locale), f = C(e == null ? void 0 : e.locale), t = e != null && e.mergeAmbiguousCharacters ? L(u, f) : w(u, f);
  return c + a.map(t).join((e == null ? void 0 : e.delimiter) ?? "") + l;
}
function U(r, e) {
  return P(r, { delimiter: "_", ...e });
}
function P(r, e) {
  const [c, a, l] = n(r, e), u = d(e == null ? void 0 : e.locale), f = C(e == null ? void 0 : e.locale);
  return c + a.map(L(u, f)).join((e == null ? void 0 : e.delimiter) ?? " ") + l;
}
function I(r, e) {
  const [c, a, l] = n(r, e);
  return c + a.map(C(e == null ? void 0 : e.locale)).join((e == null ? void 0 : e.delimiter) ?? "_") + l;
}
function b(r, e) {
  return h(r, { delimiter: ".", ...e });
}
function j(r, e) {
  return h(r, { delimiter: "-", ...e });
}
function k(r, e) {
  return h(r, { delimiter: "/", ...e });
}
function y(r, e) {
  const [c, a, l] = n(r, e), u = d(e == null ? void 0 : e.locale), f = C(e == null ? void 0 : e.locale), t = L(u, f);
  return c + a.map((m, x) => x === 0 ? t(m) : u(m)).join((e == null ? void 0 : e.delimiter) ?? " ") + l;
}
function $(r, e) {
  return h(r, { delimiter: "_", ...e });
}
function N(r, e) {
  return P(r, { delimiter: "-", ...e });
}
function d(r) {
  return r === !1 ? (e) => e.toLowerCase() : (e) => e.toLocaleLowerCase(r);
}
function C(r) {
  return r === !1 ? (e) => e.toUpperCase() : (e) => e.toLocaleUpperCase(r);
}
function L(r, e) {
  return (c) => `${e(c[0])}${r(c.slice(1))}`;
}
function w(r, e) {
  return (c, a) => {
    const l = c[0];
    return (a > 0 && l >= "0" && l <= "9" ? "_" + l : e(l)) + r(c.slice(1));
  };
}
function n(r, e = {}) {
  const c = e.split ?? (e.separateNumbers ? S : E), a = e.prefixCharacters ?? _, l = e.suffixCharacters ?? _;
  let u = 0, f = r.length;
  for (; u < r.length; ) {
    const t = r.charAt(u);
    if (!a.includes(t))
      break;
    u++;
  }
  for (; f > u; ) {
    const t = f - 1, m = r.charAt(t);
    if (!l.includes(m))
      break;
    f = t;
  }
  return [
    r.slice(0, u),
    c(r.slice(u, f)),
    r.slice(f)
  ];
}
export {
  T as camelCase,
  P as capitalCase,
  I as constantCase,
  b as dotCase,
  j as kebabCase,
  h as noCase,
  F as pascalCase,
  U as pascalSnakeCase,
  k as pathCase,
  y as sentenceCase,
  $ as snakeCase,
  E as split,
  S as splitSeparateNumbers,
  N as trainCase
};
